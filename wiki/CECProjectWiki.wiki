#summary This is where we can document some design decisions and mention things we used.

== Design Decisions ==

=== Phase 2 ===

=== Search ===

CEC Application will not perform the search in the following cases:
-Term searched is empty
-              contains only spaces
-              contains only special characters

*@ symbol is not considered as a special character

The Email search engine finds emails that contains the term wanted in at least one of the fields: From, To, CC, Subject and Body. It considers every word separately, it means that the application will return Emails that match with at least one of the words informed by the user. Special characters - except the at symbol "@"  - are not considered, and words concatenated with them are treated separately.


=== Column Widths for JTable === 

We manually call {{{defineEmailTableLayout}}} whenever the {{{updateJTable}}} is called. Is this a good design decision?

=== Error Messages for the User ===

The following cases will display an error message:

  * Try to create a folder with the same name as an existing folder
  * Try to move an email to the same folder in which it already exists


== Creation and Deletion of Folders ==

We have decided that users can *not* create folders anywhere. They may only create them as subfolders of the four "system" folders (not the emails root):

  * emails
    * Inbox
    * Drafts
    * Outbox
    * Sent

Users are also not allowed to delete any system folder. 

=== Validation on Folder Names for Creation ===

Users are only allowed to create folders with names which match our awesome regex pattern: {{{^[a-zA-Z0-9_\\s]+$}}}

YaY!



=== Formatting XML ===
In EmailXMLDao, we are using a {{{StreamSource.xls}}} file to help us format the XML output:

{{{
StreamSource stylesource = new StreamSource(getClass().getResourceAsStream("proper-indenting.xsl"));
Transformer transformer = transformerFactory.newTransformer(stylesource);
}}}

We used the following as inspiration:
http://stackoverflow.com/questions/3273182/how-to-write-properly-formatted-xml

=== How Data Looks at Each Layer (needs to be updated) ===
The persistence layer email object looks like:

{{{
<?xml version="1.0" encoding="UTF-8"?><E-Mail>
   <Id>32e61786-ef7c-4ca3-8019-df5e2ca2020d</Id>
   <From>cec@cec.com</From>
   <To>1234</To>
   <CC>4565</CC>
   <LastModifiedTime>2013.05.17_At_00.05.18.763</LastModifiedTime>
   <SentTime>2013.05.17_At_00.05.18.763</SentTime>
   <Subject>7897</Subject>
   <Body>1239</Body>
</E-Mail>
}}}

The model layer email object has the following getters:

{{{
    public UUID getId();
    public String getFrom();
    public String getTo();
    public String getCC();
    public String getSubject();
    public String getBody();
    public String getSentTime();
    public String getLastModifiedTime();
    public Folder getParentFolder();
}}}

=== Unit Testing Checked Exceptions ===

The {{{Email}}} interface extends {{{Comparable<Email>}}} in order for us to be able to sort emails (for now, based on {{{lastModifiedDate}}}). The issue we run into is that {{{SimpleDateFormat}}} method parse() throws a {{{ParseException}}}, which is a checked exception (forcing us to either add a throws keyword into the signature, or surround by try/catch). 

To circumvent this issue, we handle the exception in a protected method in the {{{EmailImpl}}} class, and inherit from this class in the unit test class {{{EmailSortingTests}}}. The handling class is overridden as follows:

{{{
	@Override
	protected void handleParseException(Exception e) {
		if (e.getClass().getName().equals("java.text.ParseException")) {
			throw new RuntimeException();
		}
	}
}}}

And then our unit test looks like:

{{{
	// We cannot cannot throw a ParseException since it is checked.  
	@Test(expected=RuntimeException.class)
	public void sortThrowsExceptionWhenBadDate() {
		Email badlyFormatedEmail = new EmailImplExceptionCUT(UUID.randomUUID(), "", "", "", "", "", 
			"xyz", "", null);
		emailList.add(badlyFormatedEmail);
		Collections.sort(emailList);
	}
}}}


=== Creation and Deletion of Folders ===

We've decided to allow subfolder creation at any point in the tree. As specified by the professor, we will prevent the deletion of Inbox (and other System folders: Drafts & Outbox).

This is accomplished by modelling a parent abstract {{{Folder}}} class, which implements the main create/updated/delete methods, and defining two subclasses: {{{SystemFolder}}} and {{{UserFolder}}}. Both subclasses override the delete method and act accordingly. A factory {{{FolderFactor}}} is responsible for creating the runtime model objects according the the rules stipulated above.

=== Sorting Folders ===

Our assumption is that users will always want to see the most recent messages on top. Therefore, each folder is sorted in a descending order. We will not (at least for phase 1) provide another means to sort.


=== Refreshing policy ===

*Folder Structure Tree - Left Panel*

We've decided to refresh the Folder Structure by rebuilting it entirely from the persistence layer  - re-scaning the "emails" directory structure from Operating system's File System - every time *a subfolder is created or deleted*. Considering that I/O and Memory overheads are not concerns as our Email application should not deal with complex directory structures with large number of subdirectories, this approach is interesting as it ensures that the user is browsing a correct and updated tree and if an error occurs the user will see his update has not been properly performed.

*Email Table - Top Panel*

Likewise, the strategy adopted to refresh the Email table when *a Folder is selected* as well as *an email is Deleted/Moved* is to request the persistence layer to check the Operating system's File System and load an updated list of Email Entities (XML Files).

----

=== UI/User Experience ===

* Look and Feel *

Look and feel (L&F) refers to the appearance of GUI widgets and their behaviors. Swing's architecture enables multiple L&Fs that provides a concrete implementation for each of the ComponentUI subclasses. To improve user experience we decided to use the L&F *SystemLookAndFeel* that implements an UI that is native to the Operating System the application is running on.


* Icons/Images *

All Icons used in our project are part of the "Primo icon set" provided freely by Double-J Design for for personal and commercial use in their website.


*Hot keys used in our application*


  * (Main window)
    * Alt+F - Open File Menu
    * Ctrl+N - New Email
    * Ctrl+F - New Sub-folder
    * Ctrl+O - Open Selected Email
    * Alt+E - Open Edit Menu
    * Ctrl+M - Move Email
    * Ctrl+E - Delete Email
    * Ctrl+R - Delete Folder

  * (Email window)
    * Alt+F - Open File Menu
    * Ctrl+D - Save as Draft
    * Ctrl+S - Send Email
    * Escape - Exit

----


== Some awesome links: ==

  * http://oreilly.com/catalog/jfcnut/chapter/ch03.html#ch03_20.html
  * http://docs.oracle.com/javase/tutorial/uiswing/components/table.html#data
  * Working with Abstract Table Model http://stackoverflow.com/questions/3090013/load-an-array-to-a-java-table
  * How to select text in a text area:
    * http://docs.oracle.com/javase/1.4.2/docs/api/javax/swing/text/JTextComponent.html
    * http://forums.codeguru.com/showthread.php?308517-How-do-you-highlight-the-text-in-a-JTextfield
    * http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html#customFocusTraversal