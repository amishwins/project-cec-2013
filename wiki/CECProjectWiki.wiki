#summary This is where we can document some design decisions and mention things we used.

== Design Decisions ==

In EmailXMLDao, we are using a {{{StreamSource.xls}}} file to help us format the XML output:

{{{
StreamSource stylesource = new StreamSource(getClass().getResourceAsStream("proper-indenting.xsl"));
Transformer transformer = transformerFactory.newTransformer(stylesource);
}}}

We used the following as inspiration:
http://stackoverflow.com/questions/3273182/how-to-write-properly-formatted-xml

The persistence layer email object looks like:

{{{
<?xml version="1.0" encoding="UTF-8"?><E-Mail>
   <Id>32e61786-ef7c-4ca3-8019-df5e2ca2020d</Id>
   <From>cec@cec.com</From>
   <To>1234</To>
   <CC>4565</CC>
   <LastModifiedTime>2013.05.17_At_00.05.18.763</LastModifiedTime>
   <SentTime>2013.05.17_At_00.05.18.763</SentTime>
   <Subject>7897</Subject>
   <Body>1239</Body>
</E-Mail>
}}}

The model layer email object has the following getters:

{{{
    public UUID getId();
    public String getFrom();
    public String getTo();
    public String getCC();
    public String getSubject();
    public String getBody();
    public String getSentTime();
    public String getLastModifiedTime();
    public Folder getParentFolder();
}}}

=== Unit Testing Checked Exceptions ===

The {{{Email}}} interface extends {{{Comparable<Email>}}} in order for us to be able to sort emails (for now, based on {{{lastModifiedDate}}}). The issue we run into is that {{{SimpleDateFormat}}} method parse() throws a {{{ParseException}}}, which is a checked exception (forcing us to either add a throws keyword into the signature, or surround by try/catch. 

To circumvent this issue, we handle the exception in a protected method in the {{{EmailImpl}}} class, and inherit from this class in the unit test class {{{EmailSortingTests}}}. The handling class is overridden as follows:

{{{
	@Override
	protected void handleParseException(Exception e) {
		if (e.getClass().getName().equals("java.text.ParseException")) {
			throw new RuntimeException();
		}
	}
}}}

And then our unit test looks like:

{{{
	// We cannot cannot throw a ParseException since it is checked.  
	@Test(expected=RuntimeException.class)
	public void sortThrowsExceptionWhenBadDate() {
		Email badlyFormatedEmail = new EmailImplExceptionCUT(UUID.randomUUID(), "", "", "", "", "", "xyz", "", null);
		emailList.add(badlyFormatedEmail);
		Collections.sort(emailList);
	}
}}}



== Some awesome links: ==

  * http://oreilly.com/catalog/jfcnut/chapter/ch03.html#ch03_20.html
  * http://docs.oracle.com/javase/tutorial/uiswing/components/table.html#data

  * Working with Abstract Table Model http://stackoverflow.com/questions/3090013/load-an-array-to-a-java-table